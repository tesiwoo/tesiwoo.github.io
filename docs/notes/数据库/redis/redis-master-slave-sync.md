---
title: redis-master-slave-sync
createTime: 2025/07/04 18:05:52
permalink: /db/8snb2ur8/
---
# Redis的高可靠性

Redis的高可靠性指两方面：
- 数据尽量少的丢失
- 服务尽量少的中断

前者由**AOF日志和RDB文件**保证，对于后者Redis的做法是**增加冗余副本**，即将一份数据同时保存在多台实例上，即使有一台实例出现故障，其他实例也可以对外提供服务，不会影响使用。


# 主从库模式

冗余副本有很多份，那么Redis是如何保证多台实例上的数据是一模一样的呢？
实际上，Redis提供了 **主从库**模式，以保证数据副本的一致性，主从库之间采用的是**读写分离的方式**。
- 读操作：主从库都可以接受
- 写操作：首先在主库执行，然后，主库将写操作同步给从库

## 主从库之间的第一次同步

1. 启动多台Redis实例时，它们相互之间可以通过`replicaof`（Redis5.0前使用的是slaveof）命令形成主库和从库的关系。
```shell
// 运行该命令的Redis实例就成为了 172.1.1.0 服务器中Redis的从库
replicaof 172.1.1.0 6379
```

2. 建立主从库管理后就会进行第一次同步
2.1. 主从库建立链接、协商同步的过程，主要是为全量复制做准备。 从库和主库建立起链接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。
&emsp; 具体而言，从库执行replicaof命令后，会给主库发送psync命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。
&emsp; psync命令包含了 `主库的runId`和`复制进度offset` 两个参数
> runID: 每个Redis实例启动时都会自动生成一个随机ID，用来唯一表示这个实例。主从库第一次同步时，从库并不知道主库的runID,所以将参数为 ？
> offset： 第一次设置为-1，表示为第一次同步
2.2. 主库收到psync命令后，会用FULLRESYNC响应命令带上两个参数：主库的runID和主库目前的复制进度offset，返回给从库。从库收到响应后会记录下这两个字段
ps：有FULLRESYNC响应就表示这是第一次同步，主库会将当前内存中所有数据同步给从库
2.3. 从库收到主库的RDB文件后会清空本地的所有数据再完成数据加载
2.4. 主库在发送RDB文件后的新的写命令记录在 replication buffer 缓冲中，当主库完成RDB文件的发送后会将缓冲中的命令发个从库。

当完成主从库第一次全量同步之后，主从库之间会一直维护一个网络连接，主库会通过这个长连接将后续收到的命令同步给从库。 这个过程叫做`基于长连接的命令传播`

## 主从级联模式
主从库之间的第一次同步是通过RDB文件进行数据全量复制的。
通过了解第一次同步的过程可以知道，主库需要完成两个耗时的操作：RDB文件的生成和RDB文件的传输。
虽然RDB文件的生成是由子进程完成的，但是fork出这个子进程的时候是会阻塞主线程的。传输RDB文件也会影响到主库的网络带宽。这样就会给主库带来很大的压力。

为了解决这个问题，于是就有了`主-从-从`模式。
即：在部署主从集群的时候，可以手动选择一个从库，给这个从库再配置一些从库，这样，丛从库的同步压力就分担到了从库上，从而有效减少了主库的压力。


## 主从库网络间断的处理

在Redis2.8之前，Redis的处理是每短一次连接主从库会重新进行一次全量同步，开销非常大。
2.8之后，网络断开之后，主从库会采用增量复制的方式继续同步。  增量存在于 repl_backlog_buffer 缓冲区中，只要主库存在从库，主库所有的写命令处理传播给从库之外，都会在这个缓冲区记录一份，缓存起来。 
> **repl_backlog_buffer：**是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己读取到的位置。
> 一开始的时候，主从库的写读位置在一起，随着主库不断的接受命令，写位置会逐渐偏离起始位置，这个偏移量就是 master_repl_offset 。 
> 从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。
>
> **replication buffer：** Redis不管是和客户端通信还是和从库通信，都是通过内存buffer 进行数据交互。 每一个客户端脸上Redis后，redis都会为其分配一个内存buffer，Redis先把> 数据写入缓冲区中，然后再把缓冲区的数据发送到客户端Scoket中再通过网络发送出去。
> 所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。
>
>

主从库重连后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。
在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。

**注意：** 因为repl_backlog_buffer是环形缓冲区，如果从库读取的速度慢于主库写的速度，就可能会导致从库还未读取的操作被主库新写的操作覆盖了，这就会导致主从库数据不一致了。
&emsp; 为避免这种情况，可以通过调整 repl_backlog_size 这个参数。它和缓冲空间的大小有关，计算公式如下 ：
> &emsp; &emsp; **缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小**







