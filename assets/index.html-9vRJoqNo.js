import{_ as t,c as i,a,o as s}from"./app-DScUAMv8.js";const n="/assets/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_163400895765-BfI-pI5i.png",l={};function r(u,e){return s(),i("div",null,e[0]||(e[0]=[a('<p>Queue：基本上，一个队列就是一个先进先出（FIFO）的数据结构 Queue继承了Collection接口，是和List，Set同级别的</p><h2 id="queue的实现" tabindex="-1"><a class="header-anchor" href="#queue的实现"><span>Queue的实现</span></a></h2><h3 id="没有实现阻塞接口-非阻塞-实现了java-util-queue接口和java-util-abstractqueue接口" tabindex="-1"><a class="header-anchor" href="#没有实现阻塞接口-非阻塞-实现了java-util-queue接口和java-util-abstractqueue接口"><span>没有实现阻塞接口（非阻塞） 实现了java.util.Queue接口和java.util.AbstractQueue接口</span></a></h3><ul><li><h2 id="内置的不阻塞队列-priorityqueue-和-concurrentlinkedqueue" tabindex="-1"><a class="header-anchor" href="#内置的不阻塞队列-priorityqueue-和-concurrentlinkedqueue"><span>内置的不阻塞队列：<strong>PriorityQueue</strong> 和 <strong>ConcurrentLinkedQueue</strong></span></a></h2></li></ul><h3 id="实现了阻塞接口的-bloclingqueue" tabindex="-1"><a class="header-anchor" href="#实现了阻塞接口的-bloclingqueue"><span>实现了阻塞接口的 (BloclingQueue)</span></a></h3><ul><li>ArrayBlockingQueue ：一个由数组支持的有界队列。</li><li>LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。</li><li>PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。</li><li>DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。</li><li>SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。</li></ul><h3 id="双端队列-deque" tabindex="-1"><a class="header-anchor" href="#双端队列-deque"><span>双端队列（Deque）</span></a></h3><p>注意：阻塞和分阻塞的就是在部分方法是否有锁（如：offer(T E)）</p><p><img src="'+n+`" alt="企业微信截图_163400895765"></p><h2 id="队列的一些操作" tabindex="-1"><a class="header-anchor" href="#队列的一些操作"><span>队列的一些操作：</span></a></h2><table><thead><tr><th>方法名</th><th>功能</th><th>失败情况</th></tr></thead><tbody><tr><td>add</td><td>往队列里新增一个元素</td><td>IIIegaISlabEepeplian异常</td></tr><tr><td>remove</td><td>移出队列头部的元素（返回头部元素并删除）</td><td>NoSuchElementException异常</td></tr><tr><td>element</td><td>返回队列头部的元素（不删除操作）</td><td>NoSuchElementException异常</td></tr><tr><td>offer</td><td>往队列里新增一个元素并返回true（已满返回false）</td><td>返回false</td></tr><tr><td>poll</td><td>移出队列头部的元素（返回头部元素并删除）</td><td>返回null</td></tr><tr><td>peek</td><td>返回队列头部的元素（不删除操作）</td><td>返回null</td></tr><tr><td>put</td><td>往队列里新增一个元素</td><td>阻塞</td></tr><tr><td>take</td><td>移出队列头部的元素（返回头部元素并删除）</td><td>阻塞</td></tr><tr><td>**remove、element、offer 、poll、peek 属于Queue接口。 **</td><td></td><td></td></tr></tbody></table><p>阻塞队列的操作可以根据它们的响应方式分为以下三类：aad、removee和element操作在你试图为一个已满的队列增加元素或从空队列取得元素时 抛出异常。在多线程程序中，队列在任何时间都可能变成满的或空的， 一般使用offer、poll、peek方法（因为它不会抛出异常）。 注意：队列中插入null值是不合法 最后，我们有阻塞操作put和take。put方法在队列满时阻塞，take方法在队列空时阻塞。</p><ul><li>LinkedBlockingQueue在不指定时容量时它的长度为Integer.MAX_VALUE，，但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素</li><li>ArrayBlockingQueue在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li>PriorityBlockingQueue是一个带优先级的队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。</li><li>DelayQueue（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。</li></ul><p><strong>队列 ：queue</strong></p><div class="language-tex line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="tex" style="--vp-collapsed-lines:15;--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">先进先出</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.add(E e)：将指定元素插入此队列中（尾插）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.element：查看这个队列的头，但是不删除</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.peek：检索但不删除此队列的头，如果队列为空返回null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.poll：检索并删除此队列的头</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.offer(E e)：不违反容量限制下，将指定的元素插入此队列中（尾插）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.remove：删除此队列的头	</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.tack：取出并删除队头的元素,当队列为空,则会一直等待直到队列有新元素可以取出,或者线程被中断抛出异常</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.put：往队列里插入元素,如果队列已经满,则会一直等待直到队列为空插入新元素,或者线程被中断抛出异常. </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">注意： 队列不能直接new Queue()出来，类似于List有其子类。如LinkedBlockingQueue&lt;E&gt;(QUEUE_LENGTH);和ArrayBlockingQueue&lt;E&gt;(QUEUE_LENGTH)：其中E指泛型，QUEUE_LENGTH可以指定容量即长度**前者是以数组的形式存储，后者是以Node节点的链表形式存储。**</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div>`,15)]))}const o=t(l,[["render",r]]),p=JSON.parse('{"path":"/JAVA/3v5y2p5f/","title":"队列-Queue","lang":"zh-CN","frontmatter":{"title":"队列-Queue","createTime":"2025/07/04 10:45:45","permalink":"/JAVA/3v5y2p5f/","description":"Queue：基本上，一个队列就是一个先进先出（FIFO）的数据结构 Queue继承了Collection接口，是和List，Set同级别的 Queue的实现 没有实现阻塞接口（非阻塞） 实现了java.util.Queue接口和java.util.AbstractQueue接口 内置的不阻塞队列：PriorityQueue 和 ConcurrentLi...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"队列-Queue\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-06T15:23:13.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://tesiwoo.top/JAVA/3v5y2p5f/"}],["meta",{"property":"og:title","content":"队列-Queue"}],["meta",{"property":"og:description","content":"Queue：基本上，一个队列就是一个先进先出（FIFO）的数据结构 Queue继承了Collection接口，是和List，Set同级别的 Queue的实现 没有实现阻塞接口（非阻塞） 实现了java.util.Queue接口和java.util.AbstractQueue接口 内置的不阻塞队列：PriorityQueue 和 ConcurrentLi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-06T15:23:13.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-06T15:23:13.000Z"}]]},"readingTime":{"minutes":4.42,"words":1327},"git":{"createdTime":1751621200000,"updatedTime":1751815393000,"contributors":[{"name":"yuxiang_chu","username":"","email":"yuxiang_chu@sui.com","commits":1,"avatar":"https://gravatar.com/avatar/4ac399a125e46d0ec8629ca6750dfd462f6865f74d1d4865199efd5f4640012f?d=retro"},{"name":"TeSiWoo","username":"TeSiWoo","email":"1666016977@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/TeSiWoo?v=4","url":"https://github.com/TeSiWoo"}]},"autoDesc":true,"filePathRelative":"notes/JAVA/集合/Queue.md","headers":[]}');export{o as comp,p as data};
