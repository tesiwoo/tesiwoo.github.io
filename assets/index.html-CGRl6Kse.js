import{_ as s,c as a,a as e,o as l}from"./app-DScUAMv8.js";const n={};function t(h,i){return l(),a("div",null,i[0]||(i[0]=[e(`<h2 id="为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#为什么要使用线程池"><span>为什么要使用线程池？</span></a></h2><p>很多时候，我们使用多线程来执行任务的时候都是这样一个场景：每新建一个任务就对应地创建一个线程，而往往每个任务在很短的时间内就结束了，导致线程的创建和销毁频繁发生，这会降低系统的效率。线程池的应用便应运而生。</p><h2 id="java线程池" tabindex="-1"><a class="header-anchor" href="#java线程池"><span>JAVA线程池</span></a></h2><h3 id="threadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor"><span>ThreadPoolExecutor</span></a></h3><p>叫：<strong>线程池任务执行器</strong></p><p>继承链：它 extends ThreadExcutorService，ThreadExcutorService implements ExecutorService，又 extends Executor</p><h4 id="重要的属性" tabindex="-1"><a class="header-anchor" href="#重要的属性"><span>重要的属性：</span></a></h4><ul><li><p>corePoolSize：核心池尺寸。当池大小小于corePoolSize时，就新建线程来执行任务。当池大小等于corePoolSize时，就将任务放进workQueue阻塞队列。池子中的空闲线程去队列中获取任务来执行。</p></li><li><p>maximumPoolSize:最大池尺寸，当队列已经满了，就新建线程入池来处理请求，但是线程数量不能超过最大池尺寸</p></li><li><p>unit:s时间单位，用TimeUnit.DAYS、TimeUnit.HOURS、TimeUnit.MINUTES、TimeUnit.SECONDS、TimeUnit.MILLISECONDS、TimeUnit.MICROSECONDS、TimeUnit.NANOSECONDS。</p></li><li><p>workQueue：阻塞队列，用来存储待执行的任务。声明类型为BlockingQueue&lt;Runnable&gt;，有几种选择：</p><table><thead><tr><th>ArrayBlockingQueue</th><th>基于数组，先进先出，必须指定大小</th></tr></thead><tbody><tr><td>LinkedBlockingQueue</td><td>基于链表，先进先出，如未指定大小，则为Integer.MAX_VALUE</td></tr><tr><td>SynchronousQueue</td><td>没有尺寸的概念，不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</td></tr><tr><td>PriorityBlockingQueue</td><td>其存储的对象必须实现Comparable接口，队列根据compare接口方法确定任务的优先级</td></tr></tbody></table></li><li><p>threadFactory：线程工厂，用来创建线程。</p></li><li><p>mainLock：线程池的主要状态锁，对线程池状态（比如线程池的大小，runstate等）的改变都要使用到这个锁</p></li><li><p>wokers：用来存放工作集合，是一个HashSet&lt;Worker&gt;</p></li><li><p>allowCoreThreadTimeOut; 是否允许为核心线程设置存活时间</p></li><li><p>keepAliveTime:线程存活时间，决定当一个线程空闲了多长时间后被销毁。只有在线程池尺寸大于corePoolSize时才起作用。</p></li><li><p>poolSize：线程池中的当前的线程数</p></li><li><p>threadFactory：线程工厂，用来创建线程</p></li><li><p>largestPoolSize：用来记录线程池中出现过的最大线程数</p></li><li><p>comletedTaskCount：用来记录已经执行完毕的任务个数。</p></li><li><p>handler，拒绝处理任务时的策略。</p><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul></li></ul><h4 id="重要方法" tabindex="-1"><a class="header-anchor" href="#重要方法"><span>重要方法</span></a></h4><ul><li>excute()：向线程池提交任务，交由线程池来执行</li><li>submit()：同样是向线程池提交任务，其内部调用了execute()，区别是，会返回一个FutureTask实例</li><li>shutdown()：等任务都执行完毕后关闭线程池，并且拒绝接受新的任务</li><li>shutdownNow()：停止正在执行的任务，立刻关闭线程池，拒绝接受新的任务</li><li>isTerminated()：检查线程池是否已关闭</li></ul><h2 id="线程池状态" tabindex="-1"><a class="header-anchor" href="#线程池状态"><span>线程池状态</span></a></h2><p>在ThreadPoolExcutor中定义了一个volatilt状态runState，另外定义了几个static final变量表示线程池的各个状态</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// runState is stored in the high-order bits</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> RUNNING</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">    =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> COUNT_BITS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//创建线程池后，初始时，线程池处于此状态</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> SHUTDOWN</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">   =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">  0</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> COUNT_BITS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//调用了shutDown()方法时，则线程处于此状态，此时线程池不能接收新的任务，它会等待所有任务执行完毕</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> STOP</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">       =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">  1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> COUNT_BITS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//调用了shurDownNow()方法时，则线程处于此状态，此时线程池不再接受新的任务，并且会去尝试终止正在执行的任务。</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TIDYING</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">    =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">  2</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> COUNT_BITS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TERMINATED</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">  3</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> COUNT_BITS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//当线程处于SHOYDOWN或者STOP状态时，并且所有工作线程都已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性。</p><h2 id="任务的执行" tabindex="-1"><a class="header-anchor" href="#任务的执行"><span>任务的执行</span></a></h2><ul><li>如果当前线程池中的线程数目pooSize&lt;corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目pooSize&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li></ul><h2 id="线程池中的线程初始化" tabindex="-1"><a class="header-anchor" href="#线程池中的线程初始化"><span>线程池中的线程初始化</span></a></h2><p>默认情况下，创建线程池之后线程池中是没有线程的，需要提交任务之后才会去创建线程。</p><p>在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个办法办到：</p><ul><li>prestartCoreThread()：初始化一个核心线程</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ul><h2 id="任务缓存队列及排队策略" tabindex="-1"><a class="header-anchor" href="#任务缓存队列及排队策略"><span>任务缓存队列及排队策略</span></a></h2><p>workQueue用来存放等待执行的任务</p><p>workQueue的类型是BlockingQueue&lt;Runable&gt;，通常取以下三种类型：</p><p>1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p><h2 id="任务拒绝策略" tabindex="-1"><a class="header-anchor" href="#任务拒绝策略"><span>任务拒绝策略</span></a></h2><p>当线程池的任务缓存队列已满且线程池中的线程数已达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略。通常有以下4中策略：</p><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li><li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul><h2 id="线程池的关闭" tabindex="-1"><a class="header-anchor" href="#线程池的关闭"><span>线程池的关闭</span></a></h2><p>线程池提供了两种关闭线程池的方法，分别是shutDown()和shutDownNow()：</p><ul><li>shutDown()：不会立即停止线程池，而是要等所有任务缓存队列中的任务都执行完毕之后才终止，但调用方法之后不会接受新的任务。</li><li>shutDownNow()：立即停止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，并返回没有尚未执行的任务。</li></ul><h2 id="线程池容量的动态调整" tabindex="-1"><a class="header-anchor" href="#线程池容量的动态调整"><span>线程池容量的动态调整</span></a></h2><p>TreadPoolSize提供了动态调整线程池容量大小的方法：setCorePoolSize()，setMaximumPoolSize()：</p><ul><li><p>setCorePoolSize()：设置核心池大小</p></li><li><p>setMaxiMumPoolSize()：设置线程池最大能创建的线程池数目大小</p></li></ul><p>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p><blockquote><p>JAVA Doc不推荐我们之间实例化ThreadPoolExcutor，而是使用它的三个静态方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newCachedThreadPool</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newSingleThreadExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //创建容量为1的缓冲池</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newFixedThreadPool</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //创建固定容量大小的缓冲池</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三个方法的实现其实只是帮我们配置好了其他的参数，具体实现如下：</p><div class="language-java line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="java" style="--vp-collapsed-lines:15;--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ExecutorService </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newFixedThreadPool</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> nThreads</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">nThreads</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> nThreads</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">           0L</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">MILLISECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">           new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> LinkedBlockingQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ExecutorService </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newSingleThreadExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> \`FinalizableDelegatedExecutorService</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">          0L</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">MILLISECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">          new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> LinkedBlockingQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()));</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ExecutorService </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newCachedThreadPool</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ThreadPoolExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">MAX_VALUE</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">           60L</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">SECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">           new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> SynchronousQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div></blockquote><h1 id="使用多线程的好处" tabindex="-1"><a class="header-anchor" href="#使用多线程的好处"><span>使用多线程的好处</span></a></h1><p>《并发编程的艺术》一书中介绍说：</p><ul><li>**降低资源消耗。**通过重复利用已创建好的线程降低创建和销毁线程造成的消耗</li><li>**提高响应速度。**当任务到达时，不用再去等待线程创建</li><li>**提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅仅是消耗系统的资源，还会降低系统的稳定性，利用线程池可以统一的分配、调优和监控。线程池一般都提供了一些常量，如已执行了的任务，当前线程数等等</li></ul><h1 id="executor框架" tabindex="-1"><a class="header-anchor" href="#executor框架"><span>Executor框架</span></a></h1><p>Executor框架是在java5之后引入的，在java5之后，通过Executor来启动线程比使用Thread的start的方法更好，除了更容易管理，效率更好（用线程池实现，减少开销）外，还有更关键的一点：有助于避免this逃逸问题。</p><blockquote><p>this逃逸：指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。</p><h2 id="executor框架结构-主要由三大部分组成" tabindex="-1"><a class="header-anchor" href="#executor框架结构-主要由三大部分组成"><span>Executor框架结构（主要由三大部分组成）</span></a></h2><h3 id="任务-runable-callable" tabindex="-1"><a class="header-anchor" href="#任务-runable-callable"><span>任务（Runable，Callable）</span></a></h3><p>执行的任务需要实现Runable或者Callable接口。Runable接口或Callable接口的实现类可以被TreadPoolExecutor或ScheduledThreadPoolExecutor执行</p><h3 id="任务执行-executor" tabindex="-1"><a class="header-anchor" href="#任务执行-executor"><span>任务执行（Executor）</span></a></h3>`,48)]))}const k=s(n,[["render",t]]),r=JSON.parse('{"path":"/JAVA/threadPool/","title":"线程池","lang":"zh-CN","frontmatter":{"title":"线程池","createTime":"2025/07/04 10:46:00","permalink":"/JAVA/threadPool/","tags":["注解"],"description":"为什么要使用线程池？ 很多时候，我们使用多线程来执行任务的时候都是这样一个场景：每新建一个任务就对应地创建一个线程，而往往每个任务在很短的时间内就结束了，导致线程的创建和销毁频繁发生，这会降低系统的效率。线程池的应用便应运而生。 JAVA线程池 ThreadPoolExecutor 叫：线程池任务执行器 继承链：它 extends ThreadExcu...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程池\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-06T15:23:13.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://tesiwoo.top/JAVA/threadPool/"}],["meta",{"property":"og:title","content":"线程池"}],["meta",{"property":"og:description","content":"为什么要使用线程池？ 很多时候，我们使用多线程来执行任务的时候都是这样一个场景：每新建一个任务就对应地创建一个线程，而往往每个任务在很短的时间内就结束了，导致线程的创建和销毁频繁发生，这会降低系统的效率。线程池的应用便应运而生。 JAVA线程池 ThreadPoolExecutor 叫：线程池任务执行器 继承链：它 extends ThreadExcu..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-06T15:23:13.000Z"}],["meta",{"property":"article:tag","content":"注解"}],["meta",{"property":"article:modified_time","content":"2025-07-06T15:23:13.000Z"}]]},"readingTime":{"minutes":7.98,"words":2394},"git":{"createdTime":1751621200000,"updatedTime":1751815393000,"contributors":[{"name":"yuxiang_chu","username":"","email":"yuxiang_chu@sui.com","commits":1,"avatar":"https://gravatar.com/avatar/4ac399a125e46d0ec8629ca6750dfd462f6865f74d1d4865199efd5f4640012f?d=retro"},{"name":"TeSiWoo","username":"TeSiWoo","email":"1666016977@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/TeSiWoo?v=4","url":"https://github.com/TeSiWoo"}]},"autoDesc":true,"filePathRelative":"notes/JAVA/多并发/threadPool.md","headers":[]}');export{k as comp,r as data};
