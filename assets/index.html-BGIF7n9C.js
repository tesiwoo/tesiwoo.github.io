import{_ as s,c as i,a as t,o as a}from"./app-DScUAMv8.js";const r={};function o(p,e){return a(),i("div",null,e[0]||(e[0]=[t(`<p>Redis在2.8.9版本中添加了hyperLogLog结构（估算） 它是用来做基数统计的结构。 <strong>优点：</strong> 输入元素非常大的时候，计算基数所需要的空间是固定且很小的（当存储的元素达到某个阈值后，需要花12kb来存这个键，可以存2^64个不同元素） <strong>缺点：</strong> hyperLogLog结构只能记录有多少个不同的元素，无法像集合一样拿出元素使用</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">pfadd</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> key</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> element</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [element...]  // 添加指定元素到key</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">pfcount</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> key</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [key...]  // 返回给定的键得基数估算值</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">pfmerge</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> destKey</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> sourcekey[sourcekey...]</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> //</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 将sourcekeys合并成一个destKey</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hyperloglog的实现原理" tabindex="-1"><a class="header-anchor" href="#hyperloglog的实现原理"><span>HyperLogLog的实现原理</span></a></h2><p>实际上，HyperLogLog不会存储每个元素的值，它使用的是概率算法。 // todo</p><h2 id="hyperloglog相关命令详解" tabindex="-1"><a class="header-anchor" href="#hyperloglog相关命令详解"><span>HyperLogLog相关命令详解：</span></a></h2><p>pfadd hll ele：将ele添加进hll的基数计算中。流程： 先对ele求hash（使用的是一种叫做MurMurHash的算法） 将hash的低14位(因为总共有2的14次方个桶)作为桶的编号，选桶，记桶中当前的值为count 从的hash的第15位开始数0，假设从第15位开始有n个连续的0（即前导0） 如果n大于count，则把选中的桶的值置为n，否则不变 pfcount hll：计算hll的基数。就是使用上面给出的DV公式根据桶中的数值，计算基数 pfmerge hll3 hll1 hll2：将hll1和hll2合并成hll3。合并方法是将所有的HyperLogLog对象合并到一个名为max的对象中，max采用的 是密集存储结构，如果被合并的对象也是密集存储结构，则循环比较每一个计数值，将大的那个存入max。</p><p>Redis的所有HyperLogLog结构都是固定的16384个桶（2的14次方），并且有两种存储格式：</p><p>稀疏格式：HyperLogLog算法在刚开始的时候，大多数桶其实都是0，稀疏格式通过存储连续的0的数目，而不是每个0存一遍，大大减小了HyperLogLog刚开始时需要占用的内存</p><p>紧凑格式：用6个bit表示一个桶，需要占用12KB内存</p><h2 id="pf-的内存占用为什么是-12k" tabindex="-1"><a class="header-anchor" href="#pf-的内存占用为什么是-12k"><span>pf 的内存占用为什么是 12k？</span></a></h2><p>我们在上面的算法中使用了1024个桶进行独立计数，不过在Redis的HyperLogLog实现中用到的是16384个桶，也就是2<sup>14，每个桶的maxbits需要6个bits来存储，最大可以表示maxbits=63，于是总共占用内存就是2</sup>14 * 6/8 = 12k 字节。</p>`,11)]))}const l=s(r,[["render",o]]),h=JSON.parse('{"path":"/db/redis-special-type/","title":"Redis的特殊类型","lang":"zh-CN","frontmatter":{"title":"Redis的特殊类型","createTime":"2025/07/04 18:05:54","permalink":"/db/redis-special-type/","tag":["Redis"],"description":"Redis在2.8.9版本中添加了hyperLogLog结构（估算） 它是用来做基数统计的结构。 优点： 输入元素非常大的时候，计算基数所需要的空间是固定且很小的（当存储的元素达到某个阈值后，需要花12kb来存这个键，可以存2^64个不同元素） 缺点： hyperLogLog结构只能记录有多少个不同的元素，无法像集合一样拿出元素使用 HyperLogL...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis的特殊类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-07T02:54:17.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://tesiwoo.top/db/redis-special-type/"}],["meta",{"property":"og:title","content":"Redis的特殊类型"}],["meta",{"property":"og:description","content":"Redis在2.8.9版本中添加了hyperLogLog结构（估算） 它是用来做基数统计的结构。 优点： 输入元素非常大的时候，计算基数所需要的空间是固定且很小的（当存储的元素达到某个阈值后，需要花12kb来存这个键，可以存2^64个不同元素） 缺点： hyperLogLog结构只能记录有多少个不同的元素，无法像集合一样拿出元素使用 HyperLogL..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-07T02:54:17.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2025-07-07T02:54:17.000Z"}]]},"readingTime":{"minutes":2.19,"words":656},"git":{"createdTime":1751623883000,"updatedTime":1751856857000,"contributors":[{"name":"yuxiang_chu","username":"","email":"yuxiang_chu@sui.com","commits":2,"avatar":"https://gravatar.com/avatar/4ac399a125e46d0ec8629ca6750dfd462f6865f74d1d4865199efd5f4640012f?d=retro"},{"name":"TeSiWoo","username":"TeSiWoo","email":"1666016977@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/TeSiWoo?v=4","url":"https://github.com/TeSiWoo"}]},"autoDesc":true,"filePathRelative":"notes/数据库/redis/02.Redis的特殊类型.md","headers":[]}');export{l as comp,h as data};
